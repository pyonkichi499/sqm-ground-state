"""
Physical observables extracted from sampled lattice configurations.

Given an ensemble of Euclidean-time paths generated by stochastic
quantization (Parisi-Wu Langevin evolution), this module computes:

- Two-point Euclidean correlator  C(tau) = <x(tau) x(0)>
- Effective mass (energy gap)     m_eff(tau) = (1/a) ln[C(tau)/C(tau+1)]
- Position histogram              approximation to |psi_0(x)|^2
- <x^2>                           related to ground-state energy via the
                                   virial theorem
"""

import numpy as np


def correlator(configs, max_tau=None):
    """Compute the Euclidean two-point correlator C(tau) = <x(tau) x(0)>.

    Uses translation invariance: average over all reference sites and all
    configurations.

        C[k] = mean over configs and sites i of x[i] * x[(i+k) % N]

    Parameters
    ----------
    configs : np.ndarray, shape (n_configs, n_lattice)
        Ensemble of lattice paths.
    max_tau : int, optional
        Maximum separation to compute.  Defaults to n_lattice // 2.

    Returns
    -------
    np.ndarray, shape (max_tau + 1,)
        C[0], C[1], ..., C[max_tau].
    """
    n_configs, n_lattice = configs.shape

    if max_tau is None:
        max_tau = n_lattice // 2

    corr = np.empty(max_tau + 1)
    for k in range(max_tau + 1):
        shifted = np.roll(configs, -k, axis=1)
        corr[k] = np.mean(configs * shifted)

    return corr


def effective_mass(corr, a=0.1):
    """Compute the effective mass (energy gap) from the correlator.

        m_eff(tau) = (1/a) * ln(C(tau) / C(tau+1))

    At large tau this converges to E_1 - E_0.  For the harmonic oscillator
    with m = 1 this equals omega.

    Parameters
    ----------
    corr : np.ndarray
        Correlator C(tau) as returned by :func:`correlator`.
    a : float
        Lattice spacing in Euclidean time.

    Returns
    -------
    np.ndarray, shape (len(corr) - 1,)
        Effective mass for each tau.  Entries are np.nan where C(tau) <= 0
        or C(tau+1) <= 0.
    """
    c_tau = corr[:-1]
    c_tau1 = corr[1:]

    valid = (c_tau > 0) & (c_tau1 > 0)

    m_eff = np.full_like(c_tau, np.nan)
    m_eff[valid] = np.log(c_tau[valid] / c_tau1[valid]) / a

    return m_eff


def position_histogram(configs, n_bins=50):
    """Compute histogram of x values (approximates |psi_0(x)|^2).

    All x values from every configuration and every site are flattened
    into a single sample and binned.  The histogram is normalised so that
    it integrates to 1 (i.e. sum(hist * bin_width) == 1).

    Parameters
    ----------
    configs : np.ndarray, shape (n_configs, n_lattice)
        Ensemble of lattice paths.
    n_bins : int
        Number of histogram bins.

    Returns
    -------
    bin_centers : np.ndarray, shape (n_bins,)
    hist_values : np.ndarray, shape (n_bins,)
        Normalised probability density at each bin center.
    """
    x_flat = configs.ravel()
    hist_values, bin_edges = np.histogram(x_flat, bins=n_bins, density=True)
    bin_centers = 0.5 * (bin_edges[:-1] + bin_edges[1:])

    return bin_centers, hist_values


def mean_x_squared(configs):
    """Compute <x^2> averaged over all sites and configurations.

    For the harmonic oscillator with mass m = 1:

        <x^2> = 1 / (2 omega)     (T -> 0 limit)

    Parameters
    ----------
    configs : np.ndarray, shape (n_configs, n_lattice)
        Ensemble of lattice paths.

    Returns
    -------
    float
        Ensemble- and site-averaged <x^2>.
    """
    return float(np.mean(configs**2))
